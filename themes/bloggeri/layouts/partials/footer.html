<footer class="footer">
    <div class="container">
        <div class="columns has-text-centered">
            {{ range .Site.Menus.footer }}
            <div class="column is-narrow">
                <a href="{{ .URL }}" class="">{{ .Name }}</a>
            </div>
            {{ end }}
        </div>
    </div>
         <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
           <link href="/pagefind/pagefind-ui.css" rel="stylesheet">
        <script src="/pagefind/pagefind-ui.js" type="text/javascript"></script>
             <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.0/color-thief.min.js"></script>
                 <script src="https://cdnjs.cloudflare.com/ajax/libs/tinycolor/1.4.1/tinycolor.min.js"></script>
    
            <script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css"/> 

    <script>
    window.addEventListener('DOMContentLoaded', (event) => {
        new PagefindUI({ element: "#search" });
    });
</script>
    <script>         
const lazy = (options = {}) => {

    const defaults = {
        elSelector: '[data-lazy]',
        animationClass: null,
        root: null,
        rootMargin: '20px 0px',
        threshold: 0.1,
        onIntersectionCallback: null
    };
    let observer = null;
    let settings;
    let els;

    const init = () => {
        settings = {...defaults, ...options};
        els = [...document.querySelectorAll(`${settings.elSelector}`)];
        if (els.length > 0) {
            intersectionObserverIsSupported() ? bindObserver(els) : load(els);
        }
    };

    const bindObserver = els => {
        observer = new IntersectionObserver(onIntersection, {
            root: settings.root,
            rootMargin: settings.rootMargin,
            threshold: settings.threshold
        });
        observe(els);
    };

    const onIntersection = entries => {
        entries.forEach(entry => {
            if (entry.intersectionRatio > 0) {
                const el = entry.target;
                load(el);
            }
        });
    };

    const observe = els => {
        if (els && observer !== null) {
            const elsArr = ensureArray(els);
            elsArr.forEach(el => observer.observe(el));
        }
    };

    const load = els => {
        if (els) {
            const elsArr = ensureArray(els);
            elsArr.forEach(el => {
                unbindObserver(el);
                if (settings.onIntersectionCallback !== null) {
                    settings.onIntersectionCallback(el);
                } else {
                    setElAttrs(el);
                }
            });
        }
    };

    const unbindObserver = el => {
        if (observer) {
            observer.unobserve(el);
        }
    };

    const setElAttrs = el => {
        if (settings.animationClass) {
            el.classList.add(settings.animationClass);
        }
        if (el.dataset.src) {
            el.src = el.dataset.src;
        }
        if (el.dataset.srcset) {
            el.srcset = el.dataset.srcset;
        }
    };

    const ensureArray = maybeArr => Array.isArray(maybeArr) ? maybeArr : [maybeArr];
    
    const intersectionObserverIsSupported = () => 'IntersectionObserver' in window;

    init();

    return {
        observe,
        load
    };

};

</script>
    <script defer src="/js/all.js"></script>
</footer>
